#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{times}

\usepackage{color}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}

\usepackage{listings}
\lstset{ %
language=C++,
frame=single,
%frame=Ltb,
%framerule=0pt,
%aboveskip=0.5cm,
%framextopmargin=3pt,
%framexbottommargin=3pt,
%framexleftmargin=0.4cm,
%framesep=0pt,
%rulesep=.4pt,
%backgroundcolor=\color{gray97},
rulesepcolor=\color{black},
stringstyle=\ttfamily,
showstringspaces = false,
basicstyle=\small\ttfamily,
commentstyle=\color{gray45},
keywordstyle=\bfseries,
numbers=left,
%numbersep=15pt,
numbersep=5pt,
%numberstyle=\tiny,
%numberfirstline = false,
breaklines=true,
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 4cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\bullet 0 2 5 -1
\bullet 1 0 24 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
USACO Training Book
\end_layout

\begin_layout Author
Autor
\end_layout

\begin_layout Date
25 de Agosto de 2013
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Primeros Pasos
\end_layout

\begin_layout Section*
Tipos de Problemas de Competencias de Programación
\end_layout

\begin_layout Standard
Hal Burch condujo un análisis durante el receso de primavera de 1999 e hizo
 un descubrimiento asombroso: ¡Solo hay 16 tipos de problemas de competencias
 de programación! Aún más, los primeros cubren casi el 80% de los problemas
 vistos en la IOI.
 Ellos son:
\end_layout

\begin_layout Itemize
Programación Dinámica
\end_layout

\begin_layout Itemize
Avaro
\end_layout

\begin_layout Itemize
Bùsqueda Completa
\end_layout

\begin_layout Itemize
Llenado Por Inundación
\end_layout

\begin_layout Itemize
Camino Mas Corto
\end_layout

\begin_layout Itemize
Técnicas de Bùsquedas Recursivas
\end_layout

\begin_layout Itemize
Arbol de Minima Expansión
\end_layout

\begin_layout Itemize
Mochila
\end_layout

\begin_layout Itemize
Geometría computacional
\end_layout

\begin_layout Itemize
Flujo de Redes
\end_layout

\begin_layout Itemize
Camino Euleriano
\end_layout

\begin_layout Itemize
Envolvente convexa bidimensional
\end_layout

\begin_layout Itemize
Numeros Grandes
\end_layout

\begin_layout Itemize
Busqueda Heurística
\end_layout

\begin_layout Itemize
Busqueda Aproximada
\end_layout

\begin_layout Itemize
Problemas Ad Hoc
\end_layout

\begin_layout Standard
Los problemas más desafiantes son Problemas Combinados los cuales involucran
 un ciclo (combinaciones, subconjuntos, etc.) alrededor de uno de los algoritmos
 antes mencionados - o aún un ciclo de un algoritmo con otro dentro de él.
 Estos parecen extraordinariamente difíciles para tener correctos, aunque
 conceptualmente son ``obvios''.
\end_layout

\begin_layout Standard
Si usted puede dominar 40% de estos tipos de problemas, se le puede casi
 garantizar a usted una medalla de plata en la IOI.
 Dominar el 80% lo promueve en el rango oro casi seguro.
 Por supuesto, ¡`dominar` es una nuez difícil de romper! Le daremos bastantes
 problemas de tal manera que usted pueda mejorar sus habilidades en su búsqueda
 por fama internacional.
 
\end_layout

\begin_layout Section
Problemas Ad Hoc
\end_layout

\begin_layout Standard
Los problemas 
\begin_inset Quotes eld
\end_inset

Ad hoc
\begin_inset Quotes erd
\end_inset

 son aquellos cuyos algoritmos no caen en ninguna categoria estandar con
 soluciones bien-estudiadas.
 Cada problema ad hoc es diferente; no existen técnicas generales o especifícas
 para resolverlos.
\end_layout

\begin_layout Standard
Por supuesto, esto hace que esos problemas sean los `divertidos', ya que
 cada uno presenta un nuevo desafío.
 Las soluciones podrían requerir una estructura novedosa o un conjunto inusual
 de ciclos o condicionales.
 Algunas veces ellos requieren combinaciones especiales que son raras, o
 al menos raramente encontradas.
\end_layout

\begin_layout Standard
Los problemas ad hoc usualmente requieren lectura cuidadosa y usualmente
 conducen a un ataque que se revuelve alrededor de una secuencia cuidadosa
 de las instrucciones dadas en el problema.
\end_layout

\begin_layout Standard
Los problemas ad hoc pueden aún requerir optimizaciones razonables y al
 menos un grado de análisis que le permita a uno evitar ciclos anidados
 cinco veces, por ejemplo.
\end_layout

\begin_layout Standard
En esta página aparecen más problemas ad hoc que otros tipos de problemas.
 Siempre esté listo para un problema ad hoc si usted no puede clasificar
 un problema como uno de los otros tipos estandar (a ser listados después).
 
\end_layout

\begin_layout Section
Búsqueda Completa 
\end_layout

\begin_layout Subsection
La Idea
\end_layout

\begin_layout Standard
Resolver un problema usando búsqueda completa se basa en el principio "Mantengál
o Simple".
 El propósito de resolver problemas de competencia es escribir programas
 que corran en el tiempo permitido, independientemente que haya un algoritmo
 más rápido.
\end_layout

\begin_layout Standard
La Busqueda Completa explota el metodo de fuerza bruta, líneal, trate-todos.
 Este método debería ser siempre el primer algoritmo/solución que usted
 debe considerar.
 Si esto trabaja dentro de las restricciones de tiempo y de espacio, entonces
 hagálo: es fácil de codificar y usualmente fácil de depurar.
 Esto significa que usted tendrá más tiempo para trabajar en los problemas
 dificiles, en los que la fuerza bruta no trabaje lo suficientemente rápido.
\end_layout

\begin_layout Standard
En el caso de un problema con solo menos de un par de millones de posibilidades,
 itere en cada una de ellas, y vea si la respuesta funciona.
\end_layout

\begin_layout Subsection*
Cuidado, Cuidado
\end_layout

\begin_layout Standard
Algunas veces no es obvio que usted use esta metodología.
\end_layout

\begin_layout Subsection*
Problema: Lamparas de Fiesta [IOI 98]
\end_layout

\begin_layout Standard
A usted se le dan N lamparas y cuatro interruptores.
 El primer interruptor maneja todas las lámparas, el segundo las pares,
 el tercero las impares, y el último las lámparas 1, 4, 7, 10, ...
\end_layout

\begin_layout Standard
Dados el número de lámparas, N, el número de veces en que se ha presionado
 un botón (hasta 10,000), y el estado de algunas de las lámparas (por ejemplo
 la lámpara 7 está apagada), dé como salida todos los posibles estados en
 que podrían estar las lámparas.
\end_layout

\begin_layout Standard
Candidamente, para cada presión de botón, usted debe considerar 4 posiblidades,
 para un total de 410000 (aproximadamente 106020 ), lo que significa que
 no hay manera en que usted podría hacer búsqueda completa (este algoritmo
 haría explotar la recursión).
\end_layout

\begin_layout Standard
Teniendo en cuenta que el orden de las presiones de botón no interesa se
 baja este número a cerca de 100004 (aproximadadmente 1016 ), aún un número
 demasiado grande para hacer búsqueda completa (pero ciertamente más cercano
 por un factor sobre 106000 ).
\end_layout

\begin_layout Standard
Sin embargo, presionar un botón dos veces es lo mismo que presionar el botón
 ninguna vez, por lo tanto todo lo que usted debe verificar es si cada botón
 se presionó 0 o 1 veces.
 Esto es solo 24 = 16 posibilidades, seguro un número de iteraciones resoluble
 dentro del límite de tiempo.
\end_layout

\begin_layout Subsection*
Problema 3: Los Relojes [IOI 94]
\end_layout

\begin_layout Standard
Un grupo de nueve relojes habita en una grilla 3 x 3; cada uno marca las
 12:00, las 3:00, las 6:00, o las 9:00.
 Su objetivo es manipularlos para que todos marquen 12:00.
 Desafortunadamente, la única manera en que usted puede manipular los relojes
 es por uno de nueve tipos diferentes de movimientos, cada uno de los cuales
 rota cierto subconjunto de los relojes 90 grados en sentido horario.
\end_layout

\begin_layout Standard
Encuentre la secuencia más corta de movimientos que pongan todos los relojes
 a las 12:00.
\end_layout

\begin_layout Standard
La cosa ''obvia'' es hacer una solución recursiva, la cual verifica si hay
 una solución de 1 movimiento, 2 movimientos, etc.
 hasta que encuentre una solución.
 Esto tomaria 9k tiempo, donde k es el número de movimientos.
 Desde que k podría ser muy grande, esto no correría razonablemente dentro
 de las limitaciones de tiempo.
\end_layout

\begin_layout Standard
Note que el orden de los movimientos no interesa.
 Esto reduce el tiempo a k9 , lo cual no es una mejora suficientemente buena.
\end_layout

\begin_layout Standard
Sin embargo, desde que hacer cada movimiento 4 veces es lo mismo que hacerlo
 ninguna vez, usted sabe que ningún movimiento será hecho más de 3 veces.
 Por lo tanto únicamente hay 49 posibilidades, lo cual es solamente 262,072,
 el cual, dada la regla de correr más de 10,000,000 operaciones en un segundo,
 debería trabajar en tiempo.
 La solución a fuerza bruta, teniendo en cuenta estas cosas, es adecuada
 perfectamente.
\end_layout

\begin_layout Subsection
Problemas Ejemplo
\end_layout

\begin_layout Subsubsection*
Vacas Lecheras [Ronda de Competencia de la USACO 1996]
\end_layout

\begin_layout Standard
Dado un horario de ordeño (El Granjero A ordeña de las 3:00 a las 10:00,
 El Granjero B de 7:00 a 12:00, etc.), calcule
\end_layout

\begin_layout Itemize
El intervalo más largo de tiempo en que al menos una vaca está siendo ordeñada
\end_layout

\begin_layout Itemize
El intervalo más largo de tiempo en que ninguna vaca está siendo ordeñada
 
\end_layout

\begin_layout Subsubsection*
Vacas Perfecas Y Vacas Primas Perfectas
\end_layout

\begin_layout Standard
Un número perfecto es aquel cuya suma de los divisores propios es igual
 al número.
 Por ejemplo, 28 = 1 + 2 + 4 + 7 + 14.
 Un par perfecto es un par de números tales que la suma de los divisores
 propios de cada uno es igual al otro.
 Hay, por supuesto, conjuntos perfectos más grandes, tales que la suma de
 los divisores del primero es igual al segundo, la de los divisores del
 segundo es igual al tercero, etc., hasta que la suma de los divisores propios
 del último es igual al primer número.
\end_layout

\begin_layout Standard
A cada vaca en el rancho del Granjero Juan se le asigna un número serial,
 de 1 a 32000.
 Una vaca perfecta es aquella que tiene asignado un número perfecto como
 su serial.
 Un grupo de vacas es un conjunto de vacas primas perfectas si sus numeros
 seriales forman un conjunto perfecto.
 Encuentre todas las vacas perfectas y todas las vacas primas perfectas.
\end_layout

\begin_layout Section
Algoritmos Avaros 
\end_layout

\begin_layout Subsubsection*
Problema Ejemplo: Reparación de Establo [Abierto de Primavera de la USACO
 1999]
\end_layout

\begin_layout Standard
Hay una lista larga de pesebreras, algunas de las cuales necesitan ser cubiertas
 con tableros.
 Usted puede usar hasta N (1 <= N <= 50) tableros, cada uno de los cuales
 puede cubrir cualquier número de pesebreras consecutivas.
 Cubra todas las pesebreras que haga falta cubrir, cubriendo tan pocas pesebrera
s como sea posible.
\end_layout

\begin_layout Subsection
La Idea
\end_layout

\begin_layout Standard
La idea básica detrás de un algoritmo avaro es construir soluciones más
 grandes a partir de soluciones más pequeñas.
 De manera diferente a otros enfoques, sin embargo, los algoritmos avaros
 mantienen únicamente la mejor solución encontrada conforme ellos van avanzando.
 Por lo tanto, para el ejemplo problema, para construir la respuesta para
 N = 5, ellos encuentran la mejor solución para N = 4, y luego la alteran
 para obtener una solución para N = 5.
 No se considera ninguna otra solución para N = 4.
\end_layout

\begin_layout Standard
Los algoritmos avaros son 
\emph on
rápidos
\emph default
, generalmente de lineales a cuadráticos y requieren poca memoria extra.
 Desafortunadamente, ellos usualmente no son correctos.
 Pero cuando funcionan, son frecuentemente fáciles de implementar y lo suficient
emente rápidos para ejecutar.
\end_layout

\begin_layout Subsubsection*
Problemas
\end_layout

\begin_layout Standard
Hay básicamente dos problemas con los algoritmos avaros.
\end_layout

\begin_layout Subsubsection*
Como Construir
\end_layout

\begin_layout Standard
¿Cómo se crea una solución más grande a partir de pequeñas? En general,
 esta es una función del problema.
 Para el problema ejemplo, la manera más obvia de ir de cuatro tableros
 a cinco es elegir un tablero y remover una sección, obteniendo por lo tanto
 dos tableros a partir de uno.
 Usted debería elegir remover la sección más grande de cualquier tablero
 que cubra solo pesebreras que no necesiten ser cubiertas (minimizando por
 lo tanto el número total de pesebreras cubiertas).
\end_layout

\begin_layout Standard
Para remover una sección de pesebreras cubiertas, tome el tablero que cubre
 esas pesebreras, y conviertalo en dos tableros: uno de los cuales cubre
 las pesebreras antes de la sección, el otro cubre las pesebreras después
 de la sección
\end_layout

\begin_layout Standard
¿Sirve?
\end_layout

\begin_layout Standard
El desafío real para el programador cae en el hecho que las soluciones avaras
 no siempre sirven.
 Aún si parecen funcionar para las entradas ejemplo, entradas aleatorias,
 y todos los casos que usted pueda pensar, si hay un caso donde no trabaje,
 al menos uno (¡si no más!) de los casos de prueba del jurado serán de esa
 forma.
\end_layout

\begin_layout Standard
Para el problema ejemplo, para ver si el algoritmo avaro antes descrito
 sirve, considere lo siguiente:
\end_layout

\begin_layout Standard
Asuma que la respuesta no contiene el hueco grande que el algoritmo removió,
 pero contiene un hueco que es menor.
 Combinando los dos tableros en los extremos del hueco más pequeño y partiendo
 el tablero a través del hueco más grande, se obtiene una respuesta que
 usa tantos tableros como la solución original pero el cual cubre menos
 pesebreras.
 Esta nueva respuesta es mejor, por lo tanto la asunción está errada y deberiamo
s elegir siempre remover el hueco más grande.
\end_layout

\begin_layout Standard
Si la respuesta no contiene este hueco en particular, pero contiene otro
 hueco el cual es tan grande, haciendo la misma transformación se tiene
 una respuesta que usa el mismo número de tableros y cubre tantas pesebreras
 como la otra respuesta.
 Esta nueva respuesta es tan buena como la solución original, pero no mejor,
 por lo tanto podemos elegir cualquiera.
\end_layout

\begin_layout Standard
Por lo tanto, existe una respuesta óptima la cual contiene el hueco grande,
 entonces, en cada paso, hay siempre una solución óptima la cual es un superconj
unto del estado actual.
 Por lo tanto, la solución final es óptima.
\end_layout

\begin_layout Subsubsection*
Conclusiones
\end_layout

\begin_layout Standard
Si existe una solución avara, uséla.
 Son fáciles de codificar, fáciles de depurar, corren rápido, y usan poca
 memoria, definen básicamente un algoritmo en términos de competencia.
 El único elemento faltante de esta lista es correctitud.
 Si el algoritmo avaro encuentra la solución correcta, uselo, pero no se
 engolosine pensando que la solución avara trabajará para todos los problemas.
\end_layout

\begin_layout Subsection
Problemas Ejemplo
\end_layout

\begin_layout Subsubsection*
Ordenando una secuencia de tres valores [IOI 1996]
\end_layout

\begin_layout Standard
A usted se le da una secuencia de tres valores (1, 2, o 3) de longitud hata
 1000.
 Encuentre el mínimo número de intercambios para poner la secuencia en orden.
\end_layout

\begin_layout Description
Algoritmo: La secuencia tiene tres partes: la parte que estará llena de
 1`s cuando esté ordenada, la parte que estará llena de 2`s cuando esté
 ordenada y la parte que estará llena de 3`s cuando esté ordenada.
 El algoritmo avaro intercambia tantos 1`s en la parte 2 con los 2´s en
 la parte 1 como sea posible, tantos 1`s en la parte 3 con 3´s en la parte
 1 como sea posible, y 2´s en la parte 3 con 3`s en la parte 2.
 Una vez que no quedan ninguno de estos tipos, los elementos restantes fuera
 de lugar necesitan ser rotados de una manera u otra en conjuntos de 3.
 Usted puede ordenar optimamente estos intercambiando todos los 1´s hacia
 su lugar y luego los 2`s.
\end_layout

\begin_layout Description
Análisis: Obviamente, un intercambio puede poner a lo más dos elementos
 en su lugar, por lo tanto todos los intercambios del primer tipo son óptimos.
 Tambièn, es claro que ellos usan diferentes tipos de elementos, por lo
 tanto no hay ''interferencia'' entre esos tipos.
 Esto implica que el orden no interesa.
 Una vez que estos intercambios han sido ejecutados, lo mejor que usted
 puede hacer es dos intercambios por cada tres elementos que no estén en
 la ubicación correcta, lo cual es lo que la segunda parta obtendrá (por
 ejemplo, ùnicamente todos los 1´s son puestos en su lugar; luego todos
 los 2`s restantes en el lugar de los 3`s y viceversa, y los que puedan
 ser intercambiados).
\end_layout

\begin_layout Subsubsection*
Monedas Amigas - Un Contraejemplo [abreviado]
\end_layout

\begin_layout Standard
Dadas las denominaciones de monedas de un pais recientemente fundado, el
 País Lechero, y una cantidad monetaria, encuentre el conjunto de monedas
 más pequeño que sume esa cantidad.
 Se garantiza que el País Lechero tendrá la moneda de 1 centavo.
\end_layout

\begin_layout Description
Algoritmo: Use la moneda con valor más alto que no sea mayor que el objetivo
 e itere en el total menos el monto obtenido con esa moneda.
\end_layout

\begin_layout Description
Análisis (incorrecto): Obviamente, usted nunca quiere usar un valor más
 pequeño de moneda, pues eso implicaría que usted tiene que usar más monedas
 para hacer la diferencia, por lo tanto este algoritmo sirve.
\end_layout

\begin_layout Description
Tal vez no: Bien, el algoritmo usualmente funciona.
 De hecho, para el sistema de monedas norteamericano {1, 5, 10, 25}, siempre
 da el conjunto óptimo.
 Sin embargo, para otros conjuntos, como {1, 5, 8, 10} y un objetivo de
 13, este algoritmo avaro daría un 10, y luego tres 1`s, para un total de
 cuatro monedas, cuando también existe la solución con dos monedas {5, 8}.
\end_layout

\begin_layout Subsubsection*
Orden Topológico
\end_layout

\begin_layout Standard
Dada una colección de objetos, junto con algunas restricciones de orden,
 tales como "A debe ir antes que B" encuentre un orden de los objetos tal
 que se cumplan las restricciones de orden.
\end_layout

\begin_layout Description
Algoritmo: Cree un grafo directo sobre los objetos, donde hay un arco de
 A a B si "A debe ir antes que B".
 Haga una pasada sobre los objetos en orden arbitrario.
 Cada vez que usted encuentre un objeto con grado-de-entrada de 0, avaramente
 pongàlo al final del ordenamiento actual, borre todos sus arcos de salida,
 y ejecute el mismo procedimiento en sus ex hijos.
 Si este algoritmo recorre todos los objetos sin poner cada objeto en el
 orden, no hay un orden que satisfaga las restricciones.
 
\end_layout

\begin_layout Section
Creando Soluciones Ganadoras
\end_layout

\begin_layout Standard
Una buena manera de obtener destreza competitiva es escribir un plan de
 acción para lo que usted va a estar haciendo durante una competencia.
 Esto lo ayudará a tener un guión para sus acciones, en términos de que
 hacer tanto cuando las cosas van bien como cuando van mal.
 De esta manera usted puede gastar su tiempo de pensar en la competencia
 pensando en problemas de programación y no tratando de imaginarse que diablos
 usted debería hacer después...
 es como precalcular sus reacciones para la mayoría de las situaciones.
\end_layout

\begin_layout Standard
La preparación mental también es importante.
\end_layout

\begin_layout Subsection
Plan de Acción para Una Ronda de Competencia
\end_layout

\begin_layout Standard
Lea 
\noun on
PRIMERO
\noun default
 completamente 
\noun on
TODOS
\noun default
 los problemas; use lápiz y papel para hacer notas con algoritmos, complejidad,
 los números, estructuras de datos, detalles tramposos, ...
\end_layout

\begin_layout Itemize
Imagínese muchos algoritmos posibles - ¡Luego elija el más tonto que funcione!
\end_layout

\begin_layout Itemize
¡
\noun on
HAGA LAS MATEMATICAS
\noun default
! (complejidad de espacio y de tiempo, y calcule los números de tiempo esperado
 y caso peor) 
\end_layout

\begin_layout Itemize
Trate de quebrar el algoritmo - use casos de pruebas especiales (¿degenerados?)
 
\end_layout

\begin_layout Itemize
Ordene los problemas: los de trabajo más corto primero, en términos de su
 esfuerzo (del más corto al más largo: hecho antes, fácil, no familiar,
 difícil)
\end_layout

\begin_layout Standard
Codificando un problema - Para cada uno, uno a la vez:
\end_layout

\begin_layout Itemize
Termine el Algoritmo 
\end_layout

\begin_layout Itemize
Cree datos de prueba para casos tramposos 
\end_layout

\begin_layout Itemize
Escriba las estructuras de datos Codifique la rutina de entrada y pruébela
 (¿escribir rutinas de salida extras para mostrar los datos ?) 
\end_layout

\begin_layout Itemize
Codifique la rutina de salida y pruébela 
\end_layout

\begin_layout Itemize
Refinamiento por Pasos: escriba comentarios que describan la lógica del
 programa
\end_layout

\begin_layout Itemize
Llene el código y depure una sección cada vez 
\end_layout

\begin_layout Itemize
Hágalo trabajar y verifique el código funcione adecuadamente (use casos
 triviales de prueba) 
\end_layout

\begin_layout Itemize
Trate de quebrar el código - use casos especiales para verificar que el
 código funcione adecuadamente
\end_layout

\begin_layout Itemize
Haga optimización progresivamente - solo tanto como sea necesario y tenga
 todas las versiones (use casos difíciles para calcular tiempo actual de
 corrida)
\end_layout

\begin_layout Subsection
Estrategia de manejo de tiempo y Escenarios de "control de daños"
\end_layout

\begin_layout Standard
Tenga un plan para que hacer cuando varias cosas (¡previsibles!) vayan mal;
 imagine problemas que usted podría tener e imagínese como va usted a reaccionar.
 La pregunta central es: "¿cuando usted gasta más tiempo depurando un programa
 y cuando usted corrige sus daños y sigue adelante?".
 Considere estos aspectos:
\end_layout

\begin_layout Itemize
¿Cuánto tiempo ha usted ya gastado depurando?
\end_layout

\begin_layout Itemize
¿Qué tipo de error parece que tiene usted?
\end_layout

\begin_layout Itemize
¿Es su algoritmo incorrecto? 
\end_layout

\begin_layout Itemize
¿Sus estructuras de datos necesitan ser cambiadas? 
\end_layout

\begin_layout Itemize
¿Tiene alguna pista de qué anda mal? 
\end_layout

\begin_layout Itemize
Cierta cantidad (20 minutos) de depuración es mejor que cambiarse a cualquier
 otra cosa; pero usted debería ser capaz de resolver otro problema de la
 nada en 45 minutos.
 
\end_layout

\begin_layout Itemize
¿Cuándo regresar a un problema que abandonó previamente? 
\end_layout

\begin_layout Itemize
¿Cuándo gastar más tiempo optimizando un programa, y cuando cambiar? 
\end_layout

\begin_layout Itemize
Considere que hacer de aquí en adelante - olvídese del esfuerzo previo,
 enfóquese en el futuro: ¿Cómo puede usted obtener más puntos en la siguiente
 hora que tiene? 
\end_layout

\begin_layout Standard
Haga una lista de puntos a hacer antes de enviar sus soluciones:
\end_layout

\begin_layout Itemize
¿Parar la codificación cinco minutos antes del fin de la competencia?
\end_layout

\begin_layout Itemize
Quite los "asserts".
\end_layout

\begin_layout Itemize
Quite toda la salida de depuración
\end_layout

\begin_layout Subsection
Sugerencias y Trucos
\end_layout

\begin_layout Itemize
Use fuerza bruta cuando se pueda !
\end_layout

\begin_layout Itemize
Lo simple es inteligente! Sugerencia: tenga cuidado con los limìtes (especificad
os en el enunciado del problema)
\end_layout

\begin_layout Itemize
Gaste memoria cuando esto hace más fácil su vida (si puede hacer realmente
 algo con esto) 
\end_layout

\begin_layout Itemize
No borre su salida extra de depuración, póngala como comentario 
\end_layout

\begin_layout Itemize
Optimice progresivamente, y solo tanto como sea necesario
\end_layout

\begin_layout Itemize
¡Mantenga todas las versiones que funcionen!
\end_layout

\begin_layout Itemize
Codifique para depurar:
\end_layout

\begin_deeper
\begin_layout Itemize
usar espacios en blanco está bien
\end_layout

\begin_layout Itemize
use nombres de variables que tengan sentido
\end_layout

\begin_layout Itemize
no reutilice variables
\end_layout

\begin_layout Itemize
refinamiento por pasos
\end_layout

\begin_layout Itemize
COMENTE ANTES DE CODIFICAR.
\end_layout

\end_deeper
\begin_layout Itemize
Evite punteros si puede 
\end_layout

\begin_layout Itemize
Evite usar memoria dinámica como si fuera una plaga: ubique todo estáticamente.
 
\end_layout

\begin_layout Itemize
Trate de no usar punto flotante; si tiene que hacerlo, ponga tolerancias
 en todo (nunca pruebe igualdad)
\end_layout

\begin_layout Itemize
Comentarios sobre comentarios:
\end_layout

\begin_deeper
\begin_layout Itemize
No use una larga prosa, solamente notas pequeñas
\end_layout

\begin_layout Itemize
Explique la funcionalidad en alto-nivel : ++i; /* aumenta el valor de i
 */ es más que inútil 
\end_layout

\begin_layout Itemize
Explique el código que use trucos 
\end_layout

\begin_layout Itemize
Delimite y documente secciones funcionales 
\end_layout

\begin_layout Itemize
Comente como si fuera para alguien inteligente quien conoce el problema,
 pero no el código 
\end_layout

\begin_layout Itemize
Comente cualquier cosa que tenga que pensar 
\end_layout

\begin_layout Itemize
Comente cualquier cosa que usted mire más de una vez diciendo, "¿Que hace
 esto otra vez?" 
\end_layout

\begin_layout Itemize
Siempre comente el orden de los índices de arreglos 
\end_layout

\end_deeper
\begin_layout Itemize
¡Mantenga un registro de su desempeño en cada competencia: sucesos, errores,
 y que podría haber hecho mejor; use esto para re-escribir y mejorar su
 plan de juego!
\end_layout

\begin_layout Subsection
Complejidad
\end_layout

\begin_layout Subsubsection*
Bases y Notación de Orden
\end_layout

\begin_layout Standard
La base fundamental del análisis de complejidad gira alrededor la noción
 de la notación ''gran O'', por ejemplo: 
\begin_inset Formula $O(N)$
\end_inset

.
 Esto significa que la velocidad de ejecución del algoritmo o su uso de
 memoria se duplicará cuando el tamaño del problema se duplique.
 Un algoritmo de 
\begin_inset Formula $O(N\text{²})$
\end_inset

 correrá cuatro veces más despacio (o usará 4 veces más espacio) cuando
 el tamaño del problema se duplique.
 Los algoritmos constantes en tiempo o en espacio se denotan por 
\begin_inset Formula $O(1)$
\end_inset

.
 Este concepto se aplica tanto a tiempo como a espacio; aquí nos concentraremos
 discutiendo en el tiempo.
\end_layout

\begin_layout Standard
Uno deduce el tiempo 
\begin_inset Formula $O()$
\end_inset

 de un programa examinando sus ciclos.
 El ciclo más anidado (y por lo tanto más lento) domina el tiempo de corrida
 y es el único mencionado cuando se discute notación 
\begin_inset Formula $O()$
\end_inset

.
 Un programa con un solo ciclo y un ciclo anidado (presumiblemente cada
 uno de los ciclos se ejecutan 
\begin_inset Formula $N$
\end_inset

 veces cada uno) es 
\begin_inset Formula $O(N\text{²})$
\end_inset

, aunque sin embargo hay también un ciclo 
\begin_inset Formula $O(N)$
\end_inset

 presente.
\end_layout

\begin_layout Standard
Por supuesto, la recursión también cuenta como un ciclo y los programas
 recursivos pueden tener ordenes como 
\begin_inset Formula $O(b^{N})$
\end_inset

, 
\begin_inset Formula $O(N!)$
\end_inset

, o aun 
\begin_inset Formula $O(N^{N})$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Reglas Prácticas
\end_layout

\begin_layout Itemize
Cuando analice un algoritmo para tener una idea de cuánto tiempo podría
 tomar para un conjunto dado de entrada, la primera regla práctica es: los
 computadores modernos (2004) pueden manejar 100M acciones por segundo.
 En un limite de cinco segundos para un programa, se pueden manejar unas
 500M acciones.
 Programas realmente bien optimizados podrían ser capaces de duplicar o
 aún cuadruplicar ese número.
 Los algoritmos desafiantes podrían únicamente ser capaces de manejar la
 mitad de eso.
 Las competencias actuales usualmente tienen un límite de tiempo de 1 segundo
 para grandes conjuntos de datos.
 
\end_layout

\begin_layout Itemize
16MB máximo de memoria para usar 
\end_layout

\begin_layout Itemize
\begin_inset Formula $2^{10}$
\end_inset

~aproximadamente~ 
\begin_inset Formula $10^{3}$
\end_inset


\end_layout

\begin_layout Itemize
Si usted tiene k ciclos anidados corriendo cada uno N iteraciones, el programa
 tiene complejidad 
\begin_inset Formula $O(N^{k})$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Si su programa es recursivo con b llamadas recursivas por nivel y tiene
 
\begin_inset Formula $l$
\end_inset

 niveles, el programa tiene complejidad 
\begin_inset Formula $O(b^{l})$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Tenga en cuenta que hay N! permutaciones y 
\begin_inset Formula $2^{n}$
\end_inset

 subconjuntos o combinaciones de N elementos cuando se trabaja con esas
 clases de algoritmos.
\end_layout

\begin_layout Itemize
Los mejores tiempos para ordenar N elementos son 
\begin_inset Formula $O(NlogN)$
\end_inset

.
\end_layout

\begin_layout Itemize

\noun on
¡HAGA LAS MATEMATICAS!
\noun default
 Encadene los números.
\end_layout

\begin_layout Subsubsection*
Ejemplos
\end_layout

\begin_layout Itemize
Un solo ciclo con N iteraciones es 
\begin_inset Formula $O(N)$
\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sum = 0
\end_layout

\begin_layout Plain Layout

for i = 1 to n
\end_layout

\begin_layout Plain Layout

  sum = sum + i
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un ciclo doblemente anidado frecuentemente es 
\begin_inset Formula $O(N^{2})$
\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# fill array a with N elements
\end_layout

\begin_layout Plain Layout

for i = 1 to n-1 
\end_layout

\begin_layout Plain Layout

  for j = i + 1 to n 
\end_layout

\begin_layout Plain Layout

    if (a[i] > a[j])
\end_layout

\begin_layout Plain Layout

       swap (a[i], a[j])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note que aunque este ciclo ejecuta 
\begin_inset Formula $Nx(N+1)/2$
\end_inset

 iteraciones de la sentencia if, es 
\begin_inset Formula $O(N^{2})$
\end_inset

 debido a que duplicar 
\begin_inset Formula $N$
\end_inset

 cuadruplica los tiempos de ejecución.
\end_layout

\begin_layout Standard
Considere este árbol binario bien balanceado con cuatro niveles: 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename imagenes/craft1.gif

\end_inset


\end_layout

\begin_layout Standard
Un algoritmo que recorra un arbol binario en general tendrá complejidad
 
\begin_inset Formula $O(2^{N})$
\end_inset

.
\end_layout

\begin_layout Subsection
Paradigmas de Solución
\end_layout

\begin_layout Subsubsection*
Generando vs.
 Filtrando
\end_layout

\begin_layout Standard
Los programas que generan montones de respuestas posibles y luego eligen
 las que son correctas (imagine el solucionador de 8-reinas) son filtros.
 Aquellos que dan exactamente la respuesta correcta sin comienzos falsos
 son generadores.
 Generalmente, los filtros son más fáciles (más rápidos) de codificar y
 corren más lentamente.
 Haga las matemáticas para ver si son los suficientemente buenos o si necesita
 crear y probar un generador.
\end_layout

\begin_layout Subsubsection*
Precálculo
\end_layout

\begin_layout Standard
Algunas veces es útil generar tablas u otras estructuras de datos que permitan
 la búsqueda más rápida posible de un resultado.
 Esto es llamado precálculo (en el cual uno intercambia espacio por tiempo).
 Uno podría compilar datos precalculados en un programa, calcularlo cuando
 el programa comience, o simplemente recordarlos cuando los calcula.
 Un programa que debe pasar letras de mayúscula a minúscula cuando están
 en mayúsculas puede hacer una tabla muy rápida de búsqueda que no requiera
 condicionales, por ejemplo.
 Los programas de competencia frecuentemente usan números primos - muchas
 veces es práctico generar una larga lista de primos para usarlos donde
 se requiera en un programa.
\end_layout

\begin_layout Subsubsection*
Descomposición (La Cosa Más Difícil en una Competencia de Programación)
\end_layout

\begin_layout Standard
Mientras que hay menos de 20 algoritmos básicos usados en problemas de competenc
ias, el desafío de problemas que requieren una combinación de dos algoritmos
 para su solución es intimidante.
 Trate de separar las pistas de diferentes partes del problema de tal manera
 que usted pueda combinar un algoritmo con un ciclo o con otro algoritmo
 para resolver diferentes partes del problema independientemente.
 Note que algunas veces usted puede usar el mismo algoritmo dos veces en
 diferentes partes (¡independientes!) de sus datos para mejorar significativamen
te su tiempo de ejecución.
\end_layout

\begin_layout Subsubsection*
Simetrias
\end_layout

\begin_layout Standard
Muchos problemas tienen simetrías (por ejemplo, la distancia entre un par
 de puntos es la misma en cualquier sentido que usted visite los puntos).
 Las simetrías pueden ser en 2 direcciones, en 4 direcciones, en 8 direcciones,
 y más.
 Trate de explotar simetrías para reducir el tiempo de ejecución.
\end_layout

\begin_layout Standard
Por ejemplo, con una simetría de 4 direcciones, usted resuelve únicamente
 la cuarta parte del problema y luego escribe las cuatro soluciones que
 comparten simetría con la respuesta (busque por soluciones auto-simétricas
 las cuales solo deberían darse en la salida una o dos veces, por supuesto).
\end_layout

\begin_layout Subsubsection*
Adelante vs.
 Atràs
\end_layout

\begin_layout Standard
Sorprendentemente, muchos problemas de competencia trabajan mucho mejor
 cuando se resuelven hacia atrás que cuando se resuelven usando un ataque
 frontal.
 Esté abierto a procesar los datos en orden inverso o a construir un ataque
 que mire los datos en algún orden o de otra manera diferente a la obvia.
\end_layout

\begin_layout Subsubsection*
Simplificación
\end_layout

\begin_layout Standard
Algunos problemas pueden ser reformulados como un problema algo diferente
 de tal manera que si usted resuelve el nuevo problema usted ya ha encontrado
 o puede encontrar fácilmente la solución al problema original; por supuesto,
 usted tiene que resolver solamente el más fácil de los dos.
 Alternativamente, como inducción, para algunos problemas uno puede hacer
 un pequeño cambio a la solución de un problema levemente más chico para
 encontrar la respuesta completa.
 
\end_layout

\begin_layout Section
Técnicas de Búsqueda
\end_layout

\begin_layout Subsubsection*
Problema Ejemplo: n Reinas [Tradicional]
\end_layout

\begin_layout Standard
Ponga n reinas en un tablero de ajedrez n x n de tal manera que ninguna
 reina sea atacada por otra.
\end_layout

\begin_layout Subsection
Búsqueda Primero en Profundidad (DFS del inglés Depth First Search)
\end_layout

\begin_layout Standard
La solución más obvia de codificar es añadir reinas recursivamente al tablero
 una por una, tratando todas las ubicaciones posibles de reinas.
 Es fácil explotar el hecho que debe haber exactamente una reina en cada
 columna: en cada paso en la recursión, simplemente elija donde poner una
 reina en la columna actual .
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

buscar(col)
\end_layout

\begin_layout Plain Layout

    si todas columnas llenas
\end_layout

\begin_layout Plain Layout

        imprimir solucion y salir 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  para cada fila
\end_layout

\begin_layout Plain Layout

      si tablero(fila, col) no esta atacada
\end_layout

\begin_layout Plain Layout

           poner reina en (fila, col)
\end_layout

\begin_layout Plain Layout

           buscar(col+1)
\end_layout

\begin_layout Plain Layout

           quitar reina en (fila, col)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Llamando 
\begin_inset Formula $buscar(0)$
\end_inset

 comienza la búsqueda.
 Esto corre rápidamente, desde que hay relativamente pocas decisiones en
 cada paso: una vez que unas pocas reinas están en el tablero, el número
 de cuadrados no atacados disminuye dramáticamente.
\end_layout

\begin_layout Standard
Esto es un ejemplo de 
\emph on
búsqueda primero en profundidad
\emph default
, debido a que el algoritmo itera hacia abajo en el árbol de búsqueda tan
 rápido como sea posible: una vez que se han puesto k reinas en el tablero,
 se examinan tableros con aún más reinas antes de examinar otros tableros
 con solamente k reinas.
 Esto está bien pero algunas veces es deseable encontrar las soluciones
 más simples antes de tratar de encontrar las más complejas.
\end_layout

\begin_layout Standard
La Búsqueda primero en profundidad verifica si cada nodo en un árbol de
 búsqueda tiene alguna propiedad.
 El árbol de búsqueda podría verse como esto:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename imagenes/rec2.gif

\end_inset


\end_layout

\begin_layout Standard
El algoritmo recorre el árbol yendo tan abajo como sea posible y luego retrocedi
endo cuando sea necesario, haciendo una especie de bosquejo del árbol cuando
 los nodos son visitados.
 Gráficamente, el árbol es recorrido en la siguiente manera: 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename imagenes/rec22.gif

\end_inset


\end_layout

\begin_layout Subsubsection
Complejidad
\end_layout

\begin_layout Standard
Suponga que hay d decisiones que deben ser hechas.
 (En este caso d=n, el número de columnas que debemos llenar.) Suponga además
 que hay C posibilidades para cada decisión.
 (En este caso c=n también, desde que cualquiera de las filas podría potencialme
nte ser elegida.) Entonces toda la búsqueda tomará tiempo proporcional a
 
\begin_inset Formula $c^{d}$
\end_inset

, esto es, una cantidad exponencial de tiempo.
 Sin embargo, este esquema requiere poco espacio: desde que solo lleva registro
 de tantas decisiones como las que hay que hacer, requiere solo espacio
 
\begin_inset Formula $O(d)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Problema Ejemplo: Cubrir con Caballos [Tradicional]
\end_layout

\begin_layout Standard
Coloque tantos caballos como sea posible en un tablero de ajedrez n x n
 de tal manera que cada cuadrado sea atacado.
 Se considera que un caballo no ataca el cuadrado en el cual está.
\end_layout

\begin_layout Subsection
Búsqueda Primero a lo Ancho(BFS del inglés Breadth First Search)
\end_layout

\begin_layout Standard
En este caso, es deseable tratar con todas las soluciones con solo k caballos
 antes de moverse a aquellos con k+1 caballos.
 Esto es llamado 
\emph on
búsqueda primero a lo ancho
\emph default
.
 La manera usual de implementar la búsqueda primero a lo ancho es usar una
 pila de estados: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

procesar(estado)
\end_layout

\begin_layout Plain Layout

    para cada siguente estado posible desde este estado
\end_layout

\begin_layout Plain Layout

        añada a la cola el siguiente estado
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

buscar()
\end_layout

\begin_layout Plain Layout

    añada a la cola el estado inicial
\end_layout

\begin_layout Plain Layout

    mientras !vacia(cola)
\end_layout

\begin_layout Plain Layout

        estado = conseguir estado de cola
\end_layout

\begin_layout Plain Layout

        procesar(estado) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esto es llamado búsqueda primero a lo ancho debido a que busca toda una
 fila entera (el ancho) de cada árbol de búsqueda antes de moverse a la
 siguiente fila.
 Para el árbol de búsqueda usado previamente, la búsqueda primero a lo ancho
 visita los nodos en este orden: 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename imagenes/rec3.gif

\end_inset


\end_layout

\begin_layout Standard
Primero visita el nodo tope, luego los nodos en el nivel 1, luego todos
 los de nivel 2, y así sucesivamente.
\end_layout

\begin_layout Subsubsection
Complejidad
\end_layout

\begin_layout Standard
Mientras que la búsqueda primero en profundidad requiere espacio proporcional
 al número de decisiones (hay n columnas para llenar en el problema de las
 n reinas, por lo tanto tomó
\begin_inset Formula $O(n)$
\end_inset

espacio), la búsqueda primero a lo ancho requiere espacio exponencial en
 el número de posibilidades.
\end_layout

\begin_layout Standard
Si hay c posibilidades en cada decisión y se han hecho k decisiones, entonces
 hay 
\begin_inset Formula $c^{k}$
\end_inset

 tableros posibles que estarán en la cola para la siguiente ronda.
 esta diferencia es de gran importancia dadas las restricciones de algunos
 ambientes de programación.
\end_layout

\begin_layout Standard

\emph on
[Algunos detalles de porque 
\begin_inset Formula $c^{k}$
\end_inset

: Considere los nodos en el árbol de recursión.
 El nivel cero tiene 1 nodo.
 El primer nivel tiene 
\begin_inset Formula $C$
\end_inset

 nodos.
 El siguiente nivel tiene 
\begin_inset Formula $c^{2}$
\end_inset

 nodos, etc.
 Por lo tanto, el número total de nodos en el nivel k-ésimo es 
\begin_inset Formula $c^{k}$
\end_inset

.]
\end_layout

\begin_layout Subsection
Busqueda por Profundidad Iterativa(ID)
\end_layout

\begin_layout Standard
Una alternativa para la búsqueda primero en ancho es profundización iterativa.En
 lugar de una sola búsqueda primero a lo ancho, corre D búsquedas primero
 en profundidad en sucesión, permitiendo que cada búsqueda vaya una fila
 más profunda que la anterior.
 Esto es, la primera búsqueda solo puede explorar la fila 1, la segunda
 la fila 2, y así sucesivamente.
 Esto "simula" una búsqueda primero a lo ancho en costo en tiempo pero ahorrando
 espacio.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

truncated_dfsearch(hnextpos, depth)
\end_layout

\begin_layout Plain Layout

    if board is covered
\end_layout

\begin_layout Plain Layout

        print solution and exit 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if depth == 0
\end_layout

\begin_layout Plain Layout

        return 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for i from nextpos to n*n
\end_layout

\begin_layout Plain Layout

        put knight at i
\end_layout

\begin_layout Plain Layout

        truncated_dfsearch(i+1, depth-1)
\end_layout

\begin_layout Plain Layout

        remove knight at i 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dfid_search
\end_layout

\begin_layout Plain Layout

    for depth = 0 to max_depth
\end_layout

\begin_layout Plain Layout

       truncated_dfsearch(0, depth)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Complejidad
\end_layout

\begin_layout Standard
La complejidad en espacio de una profundización iterativa es simplemente
 la complejidad de una búsqueda primero en profundidad: 
\begin_inset Formula $O(n)$
\end_inset

.
 La complejidad de tiempo, por otro lado, es más compleja.
 Cada búsqueda en profundidad truncada, parando en profundidad k toma 
\begin_inset Formula $c^{k}$
\end_inset

 tiempo.
 Luego si d es el número máximo de decisiones, la búsqueda en profundidad
 primero toma 
\begin_inset Formula $c^{0}+c^{1}+c^{2}+...+c^{d}$
\end_inset

 tiempo.
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $c=2$
\end_inset

, entonces esta suma es 
\begin_inset Formula $i>c^{d+1}-1$
\end_inset

, cerca del doble de tiempo que lo que hubiera tomado la búsqueda primero
 en profundidad.
 Cuando c es mayor que dos (esto es, cuando hay muchas posibilidades para
 cada decisión), la suma es aún menos: la profundización iterativa no puede
 tomar más que dos veces el tiempo que la búsqueda primero a lo ancho hubiera
 tomado, asumiendo que hay siempre al menos dos posibilidades para cada
 elección.
\end_layout

\begin_layout Subsection
¿Cuál usar?
\end_layout

\begin_layout Standard
Una vez que usted ha identificado un problema como un problema de búsqueda,
 es importante elegir el tipo adecuado de búsqueda.
 Aquí hay algunas cosas para pensar
\end_layout

\begin_layout Subsubsection*
En Resumen
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Búsqueda
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tiempo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Espacio
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cuando usarla
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DFS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O(c^k)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O(k)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se debe recorrer el árbol de todas maneras, se conoce el nivel donde están
 las respuestas, o usted no está buscando la respuesta menos profunda.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BFS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O(c^d)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O(c^ d)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se debe recorrer el árbol de todas maneras, se conoce el nivel donde están
 las respuestas, o usted no está buscando la respuesta menos profunda.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DFS+ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O(c^d)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O(d)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se quiere hacer BFS, pero no se tiene suficiente espacio, y se puede gastar
 en tiempo.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $d$
\end_inset

es la profundidad de la respuesta
\end_layout

\begin_layout Standard
\begin_inset Formula $k$
\end_inset

es la profundidad buscada 
\end_layout

\begin_layout Standard
\begin_inset Formula $d<=k$
\end_inset


\end_layout

\begin_layout Standard
Recuerde las propiedades de orden de cada búsqueda.
 Si el programa necesita producir una lista de la solución más corta primero
 (en términos de distancia desde el nodo raíz), use búsqueda primero a lo
 ancho o de profundización iterativa.
 Para otros ordenes, la búsqueda primero en profundidad es la estrategia
 adecuada.
 Si no hay suficiente tiempo para buscar todo el árbol, use el algoritmo
 que sea más apropiado para encontrar la respuesta.
 Si la respuesta se espera en una de las filas o de los nodos cercanos a
 la raíz, use búsqueda primero a lo ancho o de profundidad iterativa.
 Por el contrario, si se espera que la respuesta esté en una de las hojas,
 use la búsqueda más simple de profundidad primero.
\end_layout

\begin_layout Standard
Este seguro de tener las restricciones de espacio en mente.
 Si la memoria es insuficiente para mantener la cola para búsqueda primero
 a lo ancho pero dispone de tiempo, use profundidad iterativa.
\end_layout

\begin_layout Subsection
Problemas Ejemplo
\end_layout

\begin_layout Subsubsection*
Cadena Superprima [USACO 1994 Ronda Final, adaptado]
\end_layout

\begin_layout Standard
Un número es llamado superprimo si es primo y si cada número obtenido quitando
 algún número de digítos del lado derecho de la expansión decimal es primo.
 Por ejemplo, 233 es superprimo, porque 233, 23, y 2 son todos primos.
 Imprima una lista de todos los números superprimos de longitud n, para
 n <= 9.
 El número 1 no es primo.
\end_layout

\begin_layout Standard
Para este problema, use búsqueda primero en profundidad, desde que todas
 las respuestas van a estar en el nivel n-ésimo (el de más abajo) de la
 búsqueda.
\end_layout

\begin_layout Subsubsection*
Paseo de Betsy [USACO 1995 Ronda Clasificatoria]
\end_layout

\begin_layout Standard
Un pueblo cuadrado ha sido particionado en 
\begin_inset Formula $n^{2}$
\end_inset

 parcelas cuadradas.
 La Granja está ubicada en la parcela superior izquierda y el Mercado está
 ubicado en la parcela inferior izquierda.
 Betsy da un paseo a través del pueblo yendo de la Granja al Mercado caminando
 a través de cada parcela exactamente una vez.
 Escriba un programa que cuente de cuántas maneras diferentes Betsy puede
 ir de la Granja al Mercado para cualquier valor de n <= 6.
\end_layout

\begin_layout Standard
Como se requiere el número de soluciones, se debe buscar todo el árbol,
 aún si se encuentra rápidamente una solución.
 Por lo tanto no importa desde la perspectiva de tiempo si es usado un DFS
 o un BFS.
 Como un DFS toma menos espacio, es la búsqueda de elección para este problema.
\end_layout

\begin_layout Subsubsection*
Udder Travel [USACO 1995 Ronda Final; Piele]
\end_layout

\begin_layout Standard
La compañía Transportadora de Vacas Udder Travel tiene su centro de operaciones
 en la granja A y posee un camión de vacas el cual es usado para recoger
 y llevar vacas entre siete granjas A, B, C, D, E, F, y G.
 Las distancias (conmutativas) entre las granjas son dadas por un arreglo.
 Cada mañana, Udder Travel tiene que decidir, dado un conjunto de movimientos
 de vacas, el orden en el cual recoger y llevar las vacas para minimizar
 la distancia total recorrida.
 Aquí están las reglas:
\end_layout

\begin_layout Itemize
El camión siempre comienza de la central en la granja A y debe devolverse
 allí cuando se hayan hecho las entregas del día.
 
\end_layout

\begin_layout Itemize
El camión solamente puede llevar una vaca al tiempo.
\end_layout

\begin_layout Itemize
Las ordenes son dadas como pares de letras denotando donde se debe recoger
 una vaca seguido de a donde la vaca debe ser llevada.
\end_layout

\begin_layout Standard
Su trabajo es escribir un programa que, dado cualquier conjunto de ordenes,
 determine la ruta más corta que se encargue de todas las entregas, comenzando
 y terminando en la granja A.
\end_layout

\begin_layout Standard
Como se debe intentar con todas las posibilidades con el propósito de asegurarse
 que se encuentra el mejor, todo el árbol debe ser recorrido, lo cual toma
 la misma cantidad de tiempo usando DFS o BFS.
 Desde que DFS usa mucho menos espacio y es conceptualmente más fácil de
 implementar, úselo.
\end_layout

\begin_layout Subsubsection*
Cruzando el Desierto [IOI 1992, adaptado]
\end_layout

\begin_layout Standard
Los miembros de un grupo de nómadas del desierto están trabajando juntos
 para tratar de que uno de ellos atraviese el desierto.
 Cada nómada puede llevar cierta cantidad de litros de agua, y cada nómada
 toma cierta cantidad de agua por día, pero cada uno puede llevar una cantidad
 diferente de agua, y requiere una cantidad diferente de agua.
 Dada la capacidad de carga y los requerimientos de agua de cada nómada,
 encuentre el mínimo número de nómadas requeridos para que al menos uno
 de ellos cruce el desierto.
\end_layout

\begin_layout Standard
Todos los nómadas deben sobrevivir, por lo tanto cada nomada que comience
 el recorrido o debe regresar en algún punto, cargando suficiente agua para
 volver al inicio o debe alcanzar el otro lado del desierto.
 Sin embargo, si un nómada tiene un sobrante de agua cuando es tiempo de
 regresar, puede repartir ese sobrante entre sus amigos, si sus amigos pueden
 cargarla.
\end_layout

\begin_layout Description
Análisis: Este problema es realmente dos problemas recursivos: una recursión
 en el conjunto de nómadas a usar, el otro cuando los nómadas deben volver.
 Una búsqueda en profundidad primero con profundización iterativa trabaja
 bien aquí para determinar los nómadas requeridos, tratando primero si uno
 puede hacerlo por si solo, luego viendo si dos lo pueden hacer, etc.
\end_layout

\begin_layout Subsubsection*
Cadenas de Adición
\end_layout

\begin_layout Standard
Una cadena de adición es una secuencia de enteros tales que el primer número
 es 1, y cada número subsecuente es la suma de algunos dos números (no necesaria
mente únicos) que aparecen en la lista antes que él.
 Por ejemplo 1 2 3 5 es una cadena de esas, pues 2 es 1+1, 3 es 2+1, y 5
 es 2+3.
 Encuentre la cadena de mínima longitud que termine con un número dado.
\end_layout

\begin_layout Description
Análisis: La Búsqueda primero en profundidad con profundización iterativa
 trabaja bien aquí, pues DFS tiene una tendencia de primero intentar 1 2
 3 4 5 ...
 n, lo cual es realmente malo y la cola llega a ser muy grande rápidamente
 para BFS.
 
\end_layout

\begin_layout Section
Introducción a Números Binarios
\end_layout

\begin_layout Subsection
Representando Números Binarios
\end_layout

\begin_layout Standard
Las computadoras trabajan con 1's y 0's; estos son llamados 'bits'.
 Un byte es un grupo de 8 bits, como este: 00110101.
 Una palabra en mi computadora ('int') es de bytes: 
\end_layout

\begin_layout LyX-Code
10011010110101011010001010101011.
 
\end_layout

\begin_layout Standard
Otras computadoras tienen tamaños diferentes de palabras.
\end_layout

\begin_layout Standard
Como puede ver 32 unos y ceros es un poco incómodo de escribir (o aún leer).
 Por lo tanto, la gente convencional parte el número en grupos de 3 o 4
 bits:
\end_layout

\begin_layout LyX-Code
1001.1010.1101.0101.1010.0010.1010.1011
\end_layout

\begin_layout LyX-Code
10.011.010.110.101.011.010.001.010.101.011
\end_layout

\begin_layout LyX-Code
<-- note que el contador de 3 comienza en la derecha 
\end_layout

\begin_layout Standard
Estos conjuntos de bits son entonces enviados a dígitos, o cuatro dígitos
 por dígito hexadecimal (base 16) o tres dígitos por dígito octal (base
 8).
 Obviamente, los hexadecimales necesitan algunos nuevos dígitos (los dígitos
 decimales solo van de 0 a 9 y necesitamos 6 más).
 Actualmente, se usan las letras 'A'..'F' s para los 'dígitos' que representan
 10..15.
 Aquí está la tabla, la correspondencia es obvia:
\end_layout

\begin_layout LyX-Code
    OCTAL:                   HEXADECIMAL:
\end_layout

\begin_layout LyX-Code
  000 -> 0  100 -> 4       0000 -> 0  0100 -> 4  1000 -> 8  1100 -> C
\end_layout

\begin_layout LyX-Code
  001 -> 1  101 -> 5       0001 -> 1  0101 -> 5  1001 -> 9  1101 -> D
\end_layout

\begin_layout LyX-Code
  010 -> 2  110 -> 6       0010 -> 2  0110 -> 6  1010 -> A  1110 -> E
\end_layout

\begin_layout LyX-Code
  011 -> 3  111 -> 7       0011 -> 3  0111 -> 7  1011 -> B  1111 -> F
\end_layout

\begin_layout Standard
Por lo tanto ahora podemos escribir las representaciones hexadecimal y octal
 de aquellos enteros antes vistos rápidamente con sus notaciones para C
 y otros lenguajes:
\end_layout

\begin_layout LyX-Code
    	1001.1010.1101.0101.1010.0010.1010.1011
\end_layout

\begin_layout LyX-Code
 ->     9    A    D    5    A    2    A    B  --> 0x9AD5A2AB
\end_layout

\begin_layout LyX-Code
			    	(esto es 0x in delante del número hexadecimal)
\end_layout

\begin_layout Standard
y
\end_layout

\begin_layout LyX-Code
	     10.011.010.110.101.011.010.001.010.101.011
\end_layout

\begin_layout LyX-Code
      2   3   2   6   5   3   2   1   2   5   3 -> 023265321253
\end_layout

\begin_layout LyX-Code
		                 		(esto es un  '0' numérico delante)
\end_layout

\begin_layout Standard
El sistema octal es más fácil de escribir rápidamente, pero el hexadecimal
 tiene propiedades bonitas de distribuirse fácilmente en bytes (los cuales
 son pares de dígitos).
\end_layout

\begin_layout Subsection
Manejando Números Binarios en Programas
\end_layout

\begin_layout Standard
Algunas veces es conveniente trabajar con los bits almacenados en números
 en vez de simplemente manejarlos como enteros.
 Ejemplos de tales casos incluyen recordar elecciones (cada posición puede
 ser un indicador 'si'/'no'), manteniendo registro de banderas de opción
 (realmente la misma idea, cada posición de bit es un indicador 'si'/'no'
 de la presencia de una bandera), o llevando registro de enteros pequeños
 (esto es pares sucesivos de posiciones de bits pueden memorizar números
 de 0 a 3).
 Por supuesto, ocasionalmente los problemas pueden contener realmente 'cadenas
 de bits'.
\end_layout

\begin_layout Standard
En C/C++ y en otros lenguajes, asignar números binarios es fácil si usted
 conoce su representación octal o hexadecimal:
\end_layout

\begin_layout LyX-Code
i = 0x9AD5A2AB; 
\end_layout

\begin_layout Standard
o
\end_layout

\begin_layout LyX-Code
i = 023265321253;
\end_layout

\begin_layout Standard
Con mayor frecuencia , un conjunto de valores de bit únicos es combinado
 para crear un entero de interés.
 Uno podría pensar que la sentencia de a continuación haría eso:
\end_layout

\begin_layout LyX-Code
i = 0x10000 + 0x100; 
\end_layout

\begin_layout Standard
y lo hará – hasta que el bit de signo entre en la película y el mismo bit
 sea combinado dos veces:
\end_layout

\begin_layout LyX-Code
i = 0x100 + 0x100;
\end_layout

\begin_layout Standard
En ese caso, ocurre un 'acarreo' y entonces i contiene 0x200 en vez de 0x100
 como era probablemente lo deseado.
 La operación 'or' denotada en C/C++ y otros como '|' – hace la cosa correcta.
 Combina bits sucesivos usando estas cuatro reglas:
\end_layout

\begin_layout LyX-Code
 0|0 -> 0
\end_layout

\begin_layout LyX-Code
 0|1 -> 1
\end_layout

\begin_layout LyX-Code
 1|0 -> 1
\end_layout

\begin_layout LyX-Code
 1|1 -> 1
\end_layout

\begin_layout Standard
La operación '|' es llamada 'bitwise or' en C para no ser confundida con
 su prima '||' llamada 'or lógico' evalúa el valor aritmético de su lado
 izquierdo y, si es falso (exactamente 0), evalúa su lado derecho.
 Si cualquier evaluación es no cero, entonces '||' evalúa a verdad (exactamente
 1 en C).
 Es la regla final la que distingue al operador '|' del operador '+'.
 Algunas veces los operadores como estos son mostrados en una 'tabla de
 verdad':
\end_layout

\begin_layout LyX-Code
 | | 0  1
\end_layout

\begin_layout LyX-Code
---+------
\end_layout

\begin_layout LyX-Code
 0 | 0  1
\end_layout

\begin_layout LyX-Code
 1 | 1  1
\end_layout

\begin_layout Standard
Un '1' aparece solo cuando “ambos” bits de entrada son '1'.
 Por lo tanto, si uno quiere saber si el bit 0x100 es '1' en un entero,
 la instrucción if es simple:
\end_layout

\begin_layout LyX-Code
if (a & 0x100) { printf("yes, 0x100 is on
\backslash
n"); }
\end_layout

\begin_layout Standard
C/C++ (y otros) contienen operadores adicionales, incluyendo el o 'exclusivo'
 (denotado '^') con su tabla de verdad:
\end_layout

\begin_layout LyX-Code
 ^ | 0  1         
\end_layout

\begin_layout LyX-Code
---+------          
\end_layout

\begin_layout LyX-Code
 0 | 0  1          
\end_layout

\begin_layout LyX-Code
 1 | 1  0
\end_layout

\begin_layout Standard
Se llama al operador 'o exclusivo' algunas veces 'xor” por facilidad de
 escritura.
 Xor da un '1' si exactamente * una* des sus entradas es uno: la primera
 o la segunda, pero no las dos.
 Este operador es muy útil para 'voltear' bits, cambiándolos de '1' a '0'
 o viceversa.
 Considere esta instrucción:
\end_layout

\begin_layout LyX-Code
	a = a ^ 0x100;   /* same as a ^= 0x100; */
\end_layout

\begin_layout Standard
El bit 0z100 cambiará de 0->1 o de 1->0, dependiendo de su valor actual.
 Apagar un bit requiere dos operadores.
 El nuevo es el operador unario que voltea cada bit en una palabra, creando
 lo que se llama el 'complemento bitwise' o simplemente 'complemento' de
 una palabra.
 Algunas veces esto es llamado 'inversión de bits' o simplemente 'inversión'
 y se denota por la tilde '~'.
 Aquí hay un ejemplo rápido:
\end_layout

\begin_layout LyX-Code
char a, b;	/* eight bits, not 32 */ 	
\end_layout

\begin_layout LyX-Code
a = 0x4A;	 /* 0100.1010 */ 	
\end_layout

\begin_layout LyX-Code
b = ~a;	   /* flip every bit: 1011.0101 */ 	
\end_layout

\begin_layout LyX-Code
printf("b is 0x%X
\backslash
n", b); 
\end_layout

\begin_layout Standard
lo cual da algo como: 	
\end_layout

\begin_layout LyX-Code
b es 0xB5
\end_layout

\begin_layout Standard
Por lo tanto, si nosotros tenemos uno solo bit encendido (por ejemplo 0x100)
 entonces ~0x100 tiene todos los bits prendidos menos uno: 0xFFFFFEFF (note
 que la 'E' es el tercer 'digíto' desde la derecha)
\end_layout

\begin_layout Standard
Estos dos operadores se combinan para crear un esquema para borrar bits:
\end_layout

\begin_layout LyX-Code
a = a & (~0x100);	/* borrar el bit 0x100  */ 				
\end_layout

\begin_layout LyX-Code
                  /* lo mismo que &= ~0x100;
\end_layout

\begin_layout Standard
como todos los bits menos 1 en ~0x100 están prendidos, todos los bits menos
 el bit 0x100 aparecen en el resultado.
 Desde que el bit 0x100 está 'apagado' en ~0x100, ese bit se garantiza que
 es '0' en el resultado.
 Esta operación es llamada universalmente un 'enmascarameinto' como 'desmascarar
 el bit 0x100'.
\end_layout

\begin_layout Subsection
Resumen
\end_layout

\begin_layout Standard
En resumen, estos operadores permiten establecer, borrar, voltear y verificar
 cualquier bit o combinación, de bits en un entero:
\end_layout

\begin_layout LyX-Code
a |= 0x20;		/* prende el bit bit 0x20 */ 		
\end_layout

\begin_layout LyX-Code
a &= ~0x20;	   /* apaga el  bit 0x20  */ 		
\end_layout

\begin_layout LyX-Code
a ^= 0x20;		/* voltea el  bit 0x20 */ 		
\end_layout

\begin_layout LyX-Code
if (a & 0x20) { 			
\end_layout

\begin_deeper
\begin_layout LyX-Code
/* entonces el bit 0x20 esta prendido  */ 		
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\end_body
\end_document
