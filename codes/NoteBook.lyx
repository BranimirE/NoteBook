#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{listings}
\usepackage[spanish]{babel}
\usepackage{times}

\usepackage{color}
\definecolor{javared}{rgb}{0.6,0,0} % cadenas
\definecolor{javagreen}{rgb}{0.25,0.5,0.35} % comentarios
\definecolor{javapurple}{rgb}{0.5,0,0.35} % palabras clave
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % javadoc :D

\lstset{language=C++,
basicstyle=\ttfamily,
frame=single,
keywordstyle=\color{javapurple}\bfseries,
stringstyle=\color{javared},
commentstyle=\color{javagreen},
morecomment=[s][\color{javadocblue}]{/**}{*/},
numbers=left,
numberstyle=\small\color{black},
numbersep=10pt,
tabsize=4,
showspaces=false,
showstringspaces=false,
breaklines=true}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Ad-hoc
\end_layout

\begin_layout Section
Espicificadores de formato para printf y scanf
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Especificador
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tipo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
char
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cadena
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%d, %i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unsigned int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%ld
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
long int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%lu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unsigned long int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%lld
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
long long int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%llu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unsigned long long int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%e, %f, %g
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
float
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%lf
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
double
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
número octal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
número hexadecimal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%patron
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
patron
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Invertir Bytes
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{adhoc/utilidades.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Año bisiesto
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{adhoc/bisiesto.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Doomsday
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{adhoc/doomsday.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Estructuras
\end_layout

\begin_layout Section
Union - Find
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{estructuras/unionfind.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
BIT
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{estructuras/bit.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Segment Tree
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{estructuras/SegmenTree.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Segment Tree con Lazy Propagatión
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{estructuras/SegmenTree_lazy.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Trie
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{estructuras/trie.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Complete Search 
\end_layout

\begin_layout Section
El problema de las ocho reinas
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{busquedacompleta/ochoreinas.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Divide y venceras
\end_layout

\begin_layout Section
Busqueda Binaria (Recursivo)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{divideyvenceras/busquedabinariarecursivo.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Busqueda Binaria (Iterativo)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{divideyvenceras/busquedabinariaiterativo.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
MergeSort
\end_layout

\begin_layout Standard
Primera implementacion:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{divideyvenceras/mergesort.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Segunda implementación:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{divideyvenceras/mergesort2.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Meet in the Middle
\end_layout

\begin_layout Standard
Si generamos los subconjuntos de una lista de N elementos; sabemos que existen
 2N subconjuntos, pero esta complejidad es demasiado cuando N es grande,
 digamos (N>20).
\end_layout

\begin_layout Standard
Problema.- Dado una secuencia de N (1<= N <=34) números, determinar cuántos
 subconjuntos de esta secuencia tiene una suma entre A y B.
\end_layout

\begin_layout Standard
Esta técnica consiste en 
\emph on
dividir en dos listas por la mitad
\emph default
, Luego generamos las sumatorias de los subconjuntos de cada lista y 
\emph on
los ordenamos
\emph default
.
 Luego combinar ambos resultados.
\end_layout

\begin_layout Standard
Considerare la sumatoria de conjunto vacio como 0.
\end_layout

\begin_layout Subsubsection*
Ejemplo:
\end_layout

\begin_layout Standard
L= { 2 , 5 , 6 , 1, 9};
\end_layout

\begin_layout Standard
A=5, B=15
\end_layout

\begin_layout Standard

\series bold
Los dividimos en los listas por la mitad.
\end_layout

\begin_layout Standard
X= { 2 , 5, 6}
\end_layout

\begin_layout Standard
Y= { 1 , 9}
\end_layout

\begin_layout Standard

\series bold
Generamos los subconjuntos de cada lista.
\end_layout

\begin_layout Standard
X’ = { 0, 2, 5 , {2,5}, 6,{2,6}, {5,6} ,{2,5,6} }
\end_layout

\begin_layout Standard
Y’= { 0, 1, 9, {1,9} }
\end_layout

\begin_layout Standard

\series bold
Sumatorias de cada subconjunto de manera ordenada.
\end_layout

\begin_layout Standard
X’= {0,2,5,6,7,8,11,13}
\end_layout

\begin_layout Standard
Y’= {0,1,9,10}
\end_layout

\begin_layout Standard

\series bold
Combinar resultados
\end_layout

\begin_layout Standard
Tenemos que recorrer la lista X’ y ver cuánto nos falta para llegar al intervalo
 [A, B].
\end_layout

\begin_layout Itemize
Si el primer elemento de X’ tenemos 0 entonces en la lista Y’ tenemos que
 buscar cuantos elementos existen entre 5 y 15.
\end_layout

\begin_layout Itemize
Si el segundo elemento de X’ tenemos 2 entonces en la lista Y’ buscamos
 cuantos existen entre 3 y 13.
\end_layout

\begin_layout Standard
x
\begin_inset Graphics
	filename imagenes/meet.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
Si bien se dan cuenta es muy importante tener ambas listas de una manera
 ordenada para poder buscar cuantos elementos existen en la segunda matriz
 entre ese intervalo.
\end_layout

\begin_layout Standard
El algoritmo sigue buscando hasta terminar con el último elemento de la
 primera lista.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{divideyvenceras/meetinthemiddle.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Programación Dinamica
\end_layout

\begin_layout Section
El problema de la mochila y Subset Sum
\end_layout

\begin_layout Subsubsection*
Subset Sum:
\end_layout

\begin_layout Standard
\begin_inset Formula $OPT(j,W)=max\begin{cases}
OPT(j-1,W) & (w_{j}>W)\\
w_{j}+OPT(j-1,W-w_{j}) & (w_{j}\leq W)
\end{cases}$
\end_inset


\end_layout

\begin_layout Subsubsection*
0-1 Mochila
\end_layout

\begin_layout Standard
\begin_inset Formula $OPT(j,W)=max\begin{cases}
OPT(j-1,W) & (w_{j}>W)\\
\mathbf{v_{j}}+OPT(j-1,W-w_{j}) & (w_{j}\leq W)
\end{cases}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{programaciondinamica/mochila.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Cambio de modenas
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{programaciondinamica/coin_change.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
LIS (
\begin_inset Formula $O(n^{2})$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{programaciondinamica/lis1.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
LIS (
\begin_inset Formula $O(n\, log(n)$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{programaciondinamica/lis2.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Maxima submatriz de ceros
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{programaciondinamica/maximasubmatrizceros.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Submatriz de suma maxima
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{programaciondinamica/sumamaxima.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Distancia de edición (Algoritmo de Levenshtein)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{programaciondinamica/levenshtein.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Grafos
\end_layout

\begin_layout Section
BFS
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{grafos/bfs.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
DFS
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{grafos/dfs_ff.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Topological Sort
\end_layout

\begin_layout Standard
G asiclico dirigido (DAG) 
\end_layout

\begin_layout Standard
Las tareas no son independientes y la ejecución de una tarea sólo es posible
 si otras tareas que ya se han ejecutado.
 Solo hay un orden 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{grafos/TopSort.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Dijkstra
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{grafos/dijstra.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
BellmandFord
\end_layout

\begin_layout Standard
Si un grafo contiene un ciclo de coste total negativo entonces este grafo
 no tiene solución
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{grafos/bellmandford.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Floyd Warshall
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{grafos/FloydWarshall.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Componentes Fuertemente Conexas 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{grafos/scc.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Componentes Fuertemente Conexas (Kosaraju)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{grafos/Kosaraju.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Componentes Fuertemente Conexas (Tarjan 
\begin_inset Formula $O(n+v)$
\end_inset

 )
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{grafos/Tarjan.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Minimum Spanning Tree (Kruskall)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{grafos/kruskall.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
MaxFlow
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{grafos/MaxFlow.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Matemáticas
\end_layout

\begin_layout Section
GCD
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{matematicas/gcd.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
LCM
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{matematicas/lcm.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Exponenciación rapida
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{matematicas/exponenciacion.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Criba de Erathostenes
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{matematicas/criba.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Triangulo de Pascal
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{matematicas/pascal.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Combinaciones(Para numeros muy grandes)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{matematicas/combinaciones.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Polinomios
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{matematicas/Polinomio.java}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Fibonacci ( 
\begin_inset Formula $O(log(n))$
\end_inset

 )
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{matematicas/fibonacci.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Multiplicación entero por cadena
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{matematicas/multiplicacion.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Multiplicación de numeros grandes (Karatsuba)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{matematicas/karatsuba.java}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Integracion de Simpson
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{matematicas/integracion.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Inverso modular
\end_layout

\begin_layout Standard
Si queremos hallar 
\begin_inset Formula $a/b(mod\, p)$
\end_inset

 donde 
\begin_inset Formula $p$
\end_inset

 es 
\begin_inset Formula $primo$
\end_inset

, es lo mismo que:
\end_layout

\begin_layout Standard
\begin_inset Formula $(a*b^{-1})(mod\, p)$
\end_inset


\end_layout

\begin_layout Standard
donde 
\begin_inset Formula $b^{-1}$
\end_inset

 es el inverso modular de 
\begin_inset Formula $b$
\end_inset

 .
\end_layout

\begin_layout Standard
Para hallar el inverso modular de un numero 
\begin_inset Formula $x$
\end_inset

modulo 
\begin_inset Formula $p$
\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset Formula $x^{-1}(mod\, p)=modpow(x,p-2,p)$
\end_inset

 
\end_layout

\begin_layout Standard
Entonces, volviendo al problema:
\end_layout

\begin_layout Standard
\begin_inset Formula $a/b(mod\, p)=(a*modpow(b,p-2,p)%)%p
$
\end_inset


\end_layout

\begin_layout Chapter
Cadenas
\end_layout

\begin_layout Section
Utilidades
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{cadenas/utilidades.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Boyer Moore
\end_layout

\begin_layout Standard
Encuentra todos los match de un patron en el texto.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{cadenas/boyerMoore.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Knuth Morris Pratt 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{cadenas/kmp.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Iesima permutación
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{cadenas/ipermutacion.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Algoritmo de Manacher
\end_layout

\begin_layout Standard
El algoritmo guarda el tamaño del palindrome mas grande en LP[pos] que tiene
 como centro las posición 
\emph on
pos
\emph default
 en la cadena original
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{cadenas/manacher.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Trie
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{cadenas/trie.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Geometria Computacional
\end_layout

\begin_layout Section
Intersección de rectangulos
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{geometria/interseccionrect.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Distancia Punto - Segmento
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{geometria/puntosegmento.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Distancia Punto - Recta
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{geometria/puntorecta.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Utilitarios
\end_layout

\begin_layout Section
Plantilla
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{utilitarios/plantilla.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Lectura rapida
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{utilitarios/entrada.cpp}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Busqueda binaria
\end_layout

\begin_layout Standard
C++'s Standard Template Library has four functions for binary search, depending
 on what information you want to get.
 They all need 
\end_layout

\begin_layout LyX-Code
#include <algorithm> 
\end_layout

\begin_layout Standard
The 
\series bold
lower_bound()
\series default
 function returns an iterator to the first position where a value could
 be inserted without violating the order; i.e.
 the first element equal to the element you want, or the place where it
 would be inserted.
\end_layout

\begin_layout LyX-Code
int *ptr = std::lower_bound(array, array+len, what); 
\end_layout

\begin_layout LyX-Code
// a custom comparator can be given as fourth arg
\end_layout

\begin_layout Standard
The 
\series bold
upper_bound()
\series default
 function returns an iterator to the last position where a value could be
 inserted without violating the order; i.e.
 one past the last element equal to the element you want, or the place where
 it would be inserted.
\end_layout

\begin_layout LyX-Code
int *ptr = std::upper_bound(array, array+len, what); 
\end_layout

\begin_layout LyX-Code
// a custom comparator can be given as fourth arg
\end_layout

\begin_layout Standard
The 
\series bold
equal_range()
\series default
 function returns a pair of the results of lower_bound() and upper_bound().
\end_layout

\begin_layout LyX-Code
std::pair<int *, int *> bounds = std::equal_range(array, array+len, what);
 
\end_layout

\begin_layout LyX-Code
// a custom comparator can be given as fourth arg
\end_layout

\begin_layout Standard
Note that the difference between the bounds is the number of elements equal
 to the element you want.
\end_layout

\begin_layout Standard
The 
\series bold
binary_search()
\series default
 function returns true or false for whether an element equal to the one
 you want exists in the array.
 It does not give you any information as to where it is.
\end_layout

\begin_layout LyX-Code
bool found = std::binary_search(array, array+len, what); 
\end_layout

\begin_layout LyX-Code
// a custom comparator can be given as fourth arg
\end_layout

\end_body
\end_document
